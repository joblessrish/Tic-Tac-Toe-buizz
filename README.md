# Tic-Tac-Toe-buizz
This is just a piece of code.... well, a series of codes in a single python script, that generate random games, convert the data generated to usable formats and then that data is used to tweak values in a dictionary that contains every possible board state and assigns a "credit" to every move possible in that state of the board. 
Later, these values are used by another program, that chooses the best move possible in any given state of the game.
To be honest, though, this is a very very very very sloppy way to go about it. The reason I say so is, when you use this method, you'll notice something. Let's say, you choose to do 35,000 games. You'll notice that when trying to do a straight line in the game as the first mover, the algorithm will most likely fail to block your move but sometimes, it might block it too.... it's random, really. But, when you go for a 100,000 games, the algo will definitely fail to block a straight line move attempt. Why? That's interesting... not really. 'Caveat' might be a better word. It's more of a caveat in our approach. Crazy. I mean, think about it. When you try to play forks,the data with 35k games will sometimes fail to block them, sometimes, it'll succeed, but for the most part it fails beacause we haven't accounted for symmetry in this model. Had we accounted for symmetry, 35k games are more than enough. The point is, the data with a 100k games will do better in case of fork attempts, because... *drum rolls*.... actually, go through the code yourself and then move to the next point that has the explanation on it. Personally, I like challenges and hate it when the answer is thrown straight at my face. 

Go through the code, first.

Read it? Great.

The reason is simple. straight line threats typically happen near the beginning on a game. However, the credits are assigned to a move, based, kind of on what happens towards the end. And, e have random play going on here, so the chances that the straight line threat is blocked in the beginning by a random player, are low. This introduces a weird sort of bias that ends up skewing our statistical model. Forks however, occur much later in the game and so, less of the board is empty and even in the cases of random moves, there is a higher likelyhood of the fork succeeding in hindsight and it is rewarded accordingly, too. The same, as mentioned before, cannot be said for straight-line-plays. The best way to solve this without changing much of the core sturcture of our code/algorithm, would be to make this last multiple iterations.
If we allow ourselves to change the core structure, though, there are much better ways to do this without turning this into an explicit heuristics-based bot. One of those methods, is to write an algorithm that works based on the the concept of taking the shortest and most probable path to vicotry, one that works based on graph theory and as of the 20th of Jan 2026, as I write this README, I just stumble across this theory/thing, a few days ago and am still trying to understand it as well as possible. 
Another method to go about with this is to use parameters, that influence the moves that are played on the board. These parameters will analyze the board state n a 3-D space and parameters act accordingly. This, I think is true to my goal of building an AI engine.
